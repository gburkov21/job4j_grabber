1. Создать объект User c полями и переопределенным методом finalize

public class User {
    private int age;
    private String name;

    public User(int age, String name) {
        this.age = age;
        this.name = name;
    }

    @Override
    protected void finalize() throws Throwable {
        super.finalize();
    }
}

2. Создать несколько объектов User и руками рассчитать сколько они будет занимать памяти.
new User(33, "Ivan");

Минимальный размер объекта для 64-битного JDK составляет 16 байт. За счет заголовка = 12 байт + выравнивание для кратности 8 еще дополнительно + 4 байта.
Поле примитивного типа int = 4 байта
Поле ссылочного типа String:
Заголовок: 8 байт
Поля int внутри класса String (offset, count, hash code): 4 байта * 3 == 12 байт
64-битная ссылка на массив символов: 8 байт
8 + string.length() * 2 - размер массива символов
Получается размер строки = 36 + string.length() * 2 = 36 + 4 * 2 = 44 байта для строки "Ivan" приблизительно
В результате, объект new User(33, "Ivan") будет приблизительно занимать памяти:
16 байт заголовок объекта + 4 байта поле 'age' + 44 байта поле 'name' = 64 байта

3. Нужно найти информацию. Сколько памяти занимает пустой объект без полей.
Пустой объект равен размеру заголовка объекта, равному 16 байтам при 64-битной JVM.

4. Добиться состояния, когда виртуальная машины вызывает сборщик мусора самостоятельно. За счет ключей xmx.
Размер heap'а задается с помощью ключей -XmxNm -XmsNm
Например, при установке 7мб размера хипа:
-Xmx7m -Xms7m
Для того, чтобы виртуальная машина вызывала сборщик мусора самостоятельно в нашем примере, например можно создать 100_000 объектов размером 64 байта, как написал выше, тогда gc должен запуститься
